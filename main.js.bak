import { inject } from '@vercel/analytics';

inject();

// --- Background Orb Parallax ---
const orb = document.querySelector('.orb-1');
window.addEventListener('scroll', () => {
    // If footer is active, disable parallax updates to let CSS take over
    if (document.body.classList.contains('footer-active')) return;

    // Use a simpler parallax factor
    const scrollY = window.scrollY;
    const speed = 0.5;
    const yOffset = scrollY * speed;

    if (orb) {
        orb.style.setProperty('--scroll-offset', `${yOffset}px`);
    }
});


// --- Text Scramble Effect ---
const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+";

class TextScramble {
    constructor(el) {
        this.el = el;
        this.originalText = el.innerText;
        this.frame = 0;
        this.queue = [];
        this.scrambling = false;
        this.init();
    }

    init() {
        this.update = this.update.bind(this);
    }

    setText(newText) {
        const oldText = this.el.innerText;
        const length = Math.max(oldText.length, newText.length);
        const promise = new Promise((resolve) => this.resolve = resolve);

        this.queue = [];
        for (let i = 0; i < length; i++) {
            const from = oldText[i] || '';
            const to = newText[i] || '';
            const start = Math.floor(Math.random() * 20);
            const end = start + Math.floor(Math.random() * 30);
            this.queue.push({ from, to, start, end });
        }

        cancelAnimationFrame(this.frameRequest);
        this.frame = 0;
        this.update();
        return promise;
    }

    update() {
        let output = '';
        let complete = 0;

        for (let i = 0, n = this.queue.length; i < n; i++) {
            let { from, to, start, end, char } = this.queue[i];

            if (this.frame >= end) {
                complete++;
                output += to;
            } else if (this.frame >= start) {
                const progress = (this.frame - start) / (end - start);
                const shouldSwap = Math.random() < (1 - progress) * 0.9;

                if (!char || shouldSwap) {
                    char = this.randomChar();
                    this.queue[i].char = char;
                }
                const isGold = Math.random() < 0.5;
                output += `<span class="${isGold ? 'scramble-gold' : 'scramble-muted'} scramble-motion">${char}</span>`;
            } else {
                output += from;
            }
        }

        this.el.innerHTML = output;

        if (complete === this.queue.length) {
            this.resolve();
        } else {
            this.frameRequest = requestAnimationFrame(this.update);
            this.frame++;
        }
    }

    randomChar() {
        return letters[Math.floor(Math.random() * letters.length)];
    }
}

// Initialize Scramble on Project Titles
const titles = document.querySelectorAll('.project h2');
titles.forEach(title => {
    const fx = new TextScramble(title);
    const originalText = title.innerText;
    const card = title.closest('.project');

    card.addEventListener('mouseenter', () => {
        title.style.color = 'var(--accent)';
        fx.setText(originalText);
    });

    card.addEventListener('mouseleave', () => {
        title.style.color = '';
    });
});

// --- Mobile/Scroll Focus Logic ---
const observerOptions = {
    root: null,
    rootMargin: '-40% 0px -40% 0px',
    threshold: 0
};

const observer = new IntersectionObserver((entries) => {
    const projectsContainer = document.querySelector('.projects');

    entries.forEach(entry => {
        if (entry.isIntersecting) {
            document.querySelectorAll('.project').forEach(p => p.classList.remove('is-focused'));
            entry.target.classList.add('is-focused');
            projectsContainer.classList.add('has-focus');

            const title = entry.target.querySelector('h2');
            if (title) {
                title.style.color = 'var(--accent)';
                new TextScramble(title).setText(title.innerText);
            }
        }
    });
}, observerOptions);

const projects = document.querySelectorAll('.project');
if (window.matchMedia('(hover: none)').matches) {
    projects.forEach(project => observer.observe(project));
}

// --- Footer "Light Up" Interaction ---
const footerObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            document.body.classList.add('footer-active');
        } else {
            document.body.classList.remove('footer-active');

            // Sync parallax back when leaving footer
            // This prevents a sudden jump if the scroll position is different
            if (orb) {
                const scrollY = window.scrollY;
                const speed = 0.5;
                const yOffset = scrollY * speed;
                orb.style.setProperty('--scroll-offset', `${yOffset}px`);
            }
        }
    });
}, {
    threshold: 0.1, // Trigger slightly earlier
    rootMargin: "0px"
});

const footer = document.querySelector('footer');
if (footer) footerObserver.observe(footer);
